HPHP49-C,*°ÿ::

*****************************************************
* FIXSTO: FIXES AN ARM LIBRARY AND STORES THE LIBRARY
*         FOR PERMANENT USE
*         By Claudio Lapilli
*****************************************************

CK2

DUPTYPEZINT? ITE :: FPTR2 ^Z>R ;
:: DUPTYPEREAL? NcaseTYPEERR ;
 COERCE
 DUP 2 #> ?SEMI

 SWAP

* THIS IS (DUPTYPELIB?)
PTR $35064 NcaseTYPEERR

* MAKE SURE LIBRARY IS IN TEMPOB BEFORE WE STORE IT
CKREF

SWAP


CODE
 SAVE
 A=DAT1.A
 A+5.A
 D0=A      % D0 = BINT
 A=DAT0.S       % READ PORT NUMBER FROM STACK
 D1+5
 A=DAT1.A
 A+5.A
 D0=A           % D0 = PTR TO SIZE OF LIBRARY
 R4=A.A         % SAVE POINTER TO SIZE

% *********************************************
% FIND AN ADDRESS IN PORT MEMORY WHERE THIS
% LIBRARY WILL BE STORED
% *********************************************
 
% ENTRY: A.S = PORT# , D0->SIZE OF LIB

  A-1.S
  GONC SKPP0
  GOTO ISPORT0
*SKPP0
  A-1.S
  GONC SKPP1
  GOTO ISPORT1
*SKPP1

% ************************
% PORT2 SCANNING
% ************************

  A=DAT0.A
  A=A+15.A    % ADD LIB PROLOG + ADDITIONAL FLASH DATA + 2 FREE NIBBLES
  B=A.A       % B=REQUIRED MINIMUM SIZE



  B=0.S   % START WITH FIRST USER FLASH BANK

%% xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxX
%% MODIFIED TO RUN ON EMU49
%  B=B+7.S

%% ORIGINAL G+ CODE:
%%                  B=B+5.S
%   B=B+5.S
%% XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

*SCANFLASHLOOP
  P=0
  GOSUB MAPFLASH
  D1=(5) $4020A

*FLSHSCAN
  C=DAT1.B
  C=C+1.B
  GOC ENDOFBANK
  D1+2
  C=DAT1.A
  AD1EX
  A=A+C.A
  D1=A
  GOTO FLSHSCAN


*ENDOFBANK
  P=1
  GOSUB MAPFLASH
  P=0
  AD1EX
  D1=A
  LC(5) $4020A
  ?A=C.A
  GOYES EMPTYBANK
  A=A+B.A
  LC(5) $7FFFF
  ?A>=C.A
  GOYES SKPFFLSH
% USE CURRENT BANK
  GOTO FOUNDITFLSH
  
*EMPTYBANK  
  B=B+1.S
  A=B.S
  A=A+10.S
  GONC SCANFLASHLOOP

% ALL BANKS EMPTY
  B=B-1.S
*FNDITSHORT
  GOTO FOUNDITFLSH
*SKPFFLSH  
% IT WON'T FIT, SCAN NEXT  BANK
  B=B+1.S
  A=B.S
  A=A+10.S
  GONC SCANFLASHLOOP
% NO MORE USED BANKS, OPEN NEW ONE
*SRCHNEWBNK
  D1=(5) $4020A
  B=B-1.S
  GONC FINDNEWBANK
  GOVLNG GPMEMERR        % NO MORE BANKS, INSUFFICIENT MEMORY ERROR
*FINDNEWBANK
  P=0
  GOSUB MAPFLASH
  C=DAT1.B
  C=C+1.B
  GOC FNDNEWBANK
  P=1
  GOSUB MAPFLASH
  P=0
  GOTO SRCHNEWBNK  
*FNDNEWBANK
  P=1
  GOSUB MAPFLASH
  P=0
  GOTO FOUNDITFLSH  
  

% MAPS A FLASH BANK IN B.S
% STARTS FROM BANK8
% P=0 -> MAP
% P=1 -> UNMAP 

*MAPFLASH
  C=0.A
  C=B.S
  CPEX.15
  CPEX.0   % P=0, C.0=BANK NUMBER
  LA(5) ACCESSBank8

  % EACH ROUTINE TAKES 7 NIBBLES
  A=A+C.A
  C=C+C.A
  A=A+C.A
  C=C+C.A
  A=A+C.A   % A=A+7*C

  CPEX.15
  PC=A       % JUMP TO THE MAPPING ROUTINE


*ISPORT1


% ************************
% PORT1 SCANNING
% ************************

  A=DAT0.A
  A=A+10.A    % ADD LIB PROLOG + 5 FREE NIBBLES
  B=A.A       % B=REQUIRED MINIMUM SIZE



  B=0.S   
  B=B-1.S     % MARK THAT IF B.S=F --> ERAM

  P=0
  GOSBVL ACCESSERAM1
  D1=(5) $40000

*ERAMSCAN
  C=DAT1.A
  C=C-1.A
  GOC ENDOFERAM
  D1+5
  C=DAT1.A
  AD1EX
  A=A+C.A
  D1=A
  GOTO ERAMSCAN


*ENDOFERAM
  P=1
  GOSBVL ACCESSERAM1
  P=0
  AD1EX
  D1=A
  A=A+B.A
  LC(5) $7F000
  ?A<C.A
  GOYES FOUNDIT

  GOVLNG GPMEMERR        % INSUFFICIENT MEMORY ERROR



  % **********************************************
  % NOT YET IMPLEMENTED

*ISPORT0
  LC(5) $11308
  GOVLNG GPErrjmpC

*FOUNDITFLSH
  D1+8   % SKIP ADDITIONAL FLASH INFO

*FOUNDIT

  % D1 -> ABSOLUTE ADDRESS WHERE THE LIBRARY WILL BE STORED
  % B.S = FLASH BANK WHERE IT WILL BE STORED - 8 (F=ERAM)
  AD1EX
  A+5.A   % POINT TO THE SIZE OF THE LIBRARY (SAME AS R4)
  R3=A.A  % SAVE FUTURE ADDRESS FOR ALIGNMENT
  A=R4.A
  D0=A    % RESTORE D0->SIZE



% *********************************************
% FIND ARM CODE WITHIN THE LIBRARY
% *********************************************

% B.S = FLASH BANK NUMBER
% R3 = FINAL ADDRESS (W/O PROLOG)
% R4 = ACTUAL ADDRESS (W/O PROLOG)


 D0+5
 C=0.A
 C=DAT0.B       % LENGTH OF TITLE
 D0+2
 ?C=0.B
 GOYES NOSKPTITLE
 AD0EX
 A+C.A
 A+C.A
 A+2.A
 AD0EX

% D0 POINTS AFTER THE TITLE
*NOSKPTITLE
 D0+13        % SKIP ROMID (3) + HASH PTR (5) + MESS PTR (5)
 C=DAT0.A     % READ LINK TABLE PTR
 AD0EX
 A+C.A
 A+5.A        % SKIP PROLOG OF HASH TABLE
 D0=A
 A=DAT0.A
 A-5.A        % A=5*NUMBER OF XLIB'S TO SCAN
 B=A.A
 D0+5

*ALIGNXLIB
 ?B=0.A
 GOYES DONEALIGN
 A=DAT0.A
 CD0EX
 A=A+C.A
 CD0EX
 D1=A

 % D1 -> PROLOG OF OBJECT TO ALIGN
 % MUST PRESERVE B (COUNTER),D0, R3 AND R4

 GOSUB ALIGNOBJECT

 B=B-5.A
 D0+5
 GOTO ALIGNXLIB

*DONEALIGN

% NOW FIX THE CRC OF THE LIBRARY


 A=R4.A
 D0=A
 A=DAT0.A
 A=A-4.A
 GOSBVL DoCRC
 DAT0=A.4

 
% DONE, RETURN SOME RESULTS TO SYSRPL FOR CHECKS

% GET ROMID OF THE LIBRARY
 A=R4.A
 D0=A
 D0+5
 C=0.A
 C=DAT0.B
 C+C.A
 C=C+9.A
 A=A+C.A
 D0=A
 C=DAT0.3
 R0=C.A

 GOSBVL GETPTR

 A=0.W
 A=R0.A
 ASL.W
 ASL.W
 ASL.W
 ASL.W
 ASL.W
 A=B.S
 A=R3.A
 A=A-5.A  % POINT TO PROLOG OF LIBRARY
 
 P=15
 GOVLNG PUSHhxsLoop




% *********************************************
% ALIGN THE CODE IF IT IS AN ARM PROGRAM
% *********************************************

*ALIGNOBJECT

% ENTRY: D1=PROLOG OF OBJ
%        R3=ABSOLUTE ADDRESS OF LIBRARY (W/O PROLOG)
%        R4=ACTUAL ADDRESS OF LIBRARY (W/O PROLOG)
% USES: ALL BUT B, D0, R3 AND R4

 A=DAT1.A
 LC(5) DOEXT0
 ?C=A.A
 GOYES ISLIBDATA
 LC(5) DOHXS
 ?C=A.A
 GOYES ISLIBDATA
 LC(5) DOCSTR
 ?C#A.A
 RTNYES       % IT'S NOT AN ARM PROGRAM

*ISLIBDATA
 D1+10
 C=DAT1.A   % READ HEADER
 LA(5) $0B34C
 ?C#A.A     % IF STARTS WITH \\\\\\\"L\\\\179\\\\\\\" IS VALID
 RTNYES     % NOT AN ARM V3 PROGRAM

 D1-5       % POINT TO OBJECT SIZE
 C=DAT1.A   % READ SIZE OF LIBDATA OBJECT
 C=C-5.A
 C=C-14.A   % C=SIZE OF ARM PROGRAM
 R0=C.A     % R0=SIZE
 D1+10      % SKIP SIZE AND MARKER
 C=0.A
 C=DAT1.1   % READ OFFSET TO ARM CODE
 AD1EX
 D1=A
 A=A+1.A    % SKIP OFFSET
 ACEX.A
 D=C.A      % D=SAVED SCRATCH AREA
 A=A+C.A    % A=ACTUAL START OF ARM CODE
 R1=A.A     % R1=SAVED ACTUAL ADDR

 C=R4.A
 A=A-C.A    % CALC OFFSET WITHIN LIBRARY
 C=R3.A
 A=A+C.A    % ABS FINAL ADDRESS
 C=A.A
 A=A+A.P
 ?A#0.P     % CHECK IF ADDRESS IS WORD ALIGNED
 GOYES MISALIGNED
 GOTO ISALIGNED2
*MISALIGNED
% CODE WAS MISALIGNED, FIX IT
 C=D.A
 A=R4.A
 C=C-A.A
 A=R3.A
 C=C+A.A    % C=ABS ADDRESS
 C=C+7.A
 LA(1) 8
 C=C&A.P    % C=NEW ALIGNED ADDRESS
 A=R3.A
 C=C-A.A    % OFFSET
 A=R4.A
 C=C+A.A    % NEW ADDRESS IN RAM
 R2=C.A     % R2=SAVED NEW ADDR
 C=C-D.A    % C=OFFSET OF THE RELOCATED CODE
 DAT1=C.P
 A=R2.A     % A=NEW ADDR
 C=R1.A     % C=ORG ADDR
 R1=A.A     % SAVE NEW ADDRESS AS ACTUAL
 ?A<C.A
 GOYES DOMDOWN  % DECIDE IF COPY UP OR DOWN

 CR0EX.A     % C=SIZE OF CODE
 A=A+C.A    % POINT TO END OF BLOCK
 D1=A       % D1=DEST
 A=C.A
 CR0EX.A
 C=C+A.A    % POINT TO END OF BLOCK
 CD0EX    % D0=SOURCE
 R2=C.A     % R2=SAVED D0
 C=R0.A
 GOSBVL MOVEUP
 GOTO ISALIGNED

*DOMDOWN
 D1=A       % D1=DEST
 CD0EX    % D0=SOURCE
 R2=C.A     % R2=SAVED D0
 C=R0.A     % C=SIZE
 GOSBVL MOVEDOWN

*ISALIGNED
 
 C=R2.A
 D0=C       % RESTORE SAVED D0 

*ISALIGNED2

 % ************************************************************
 % FIX RELOCATION TABLES HERE
 % ************************************************************
 
 % ENTRY:
 % R0=SIZE OF ARM CODE
 % R1=ACTUAL START OF CODE
 % R3=ABSOLUTE FINAL ADDR W/O PROLOG
 % R4=ACTUAL ADDRESS W/O PROLOG
 % B.S = FLASH BANK NUMBER ( 0= BANK8, 5=BANK D , F=ERAM1)

 % MUST PRESERVE D0, B, R3, R4


  A=R1.A
  C=R0.A
  A=A+C.A     % POINT TO END OF CODE
  A=A-8.A     % POINT TO STRUCTURE MARKER
  D1=A
  
  A=0.W
  C=0.W
  A=DAT1.8
  LC(8) $3176B34C
  
  ?A#C.W
  RTNYES      % RETURN IF NO STRUCTURE

  A=0.W
  A=R1.A
  C=R4.A
  A=A-C.A
  C=R3.A
  A=A+C.A     % A=ABSOLUTE START OF CODE
  
  ASRB.A      % SAT/2
  C=0.A
  C=B.S
  C=C+1.S
  GOC ERAMCONVERT
  P=C.15
  C=P.4
  P=0
  C=C+C.A     % 0x20000 * (nBANKS+1)
  A=A+C.A
  P=5
  LA(1) 1
  P=0         % A=ARM DOMAIN ADDRESS

  GOTO DOADDR
*ERAMCONVERT
  P=6
  LA(1) 8
  P=0

*DOADDR

  D1-8
  C=0.W
  C=DAT1.8    % PRIMARY OFFSET
  R1=A.W      % R1=NEW ARM ADDR
  R2=C.W      % KEEP ORIGINAL FOR CALCULATIONS
  DAT1=A.8    % STORE THE ARM ABS ADDRESS
  
  D1-8        % POINT TO PR.ENTRY PT
  A=DAT1.8
  A=A-C.W     % OFFSET 
  C=R1.W
  A=A+C.W     % NEW ADDR
  DAT1=A.8

  D1-16       % POINT TO NUMBER OF ENTRY POINTS

  C=DAT1.A
  D=C.A       % COUNTER
  D1-8

*ENTRYPTLOOP
  ?D=0.A
  RTNYES      % NOTHING ELSE TO DO      

  A=DAT1.8    % READ OLD ADDRESS
  C=R2.W      % ORIGINAL ADDR
  A=A-C.W     % CALCULATE OFFSET

  C=R1.W      % NEW ADDR
  A=A+C.W
  DAT1=A.8    % WRITE NEW ARM ADDRESS

  D1-16
  D=D-1.A
  GOTO ENTRYPTLOOP



ENDCODE


* CONTINUE FROM RPL

UNROT
UNCOERCE

* STORE THE FIXED LIBRARY AS USUAL
xSTO

CODE

 % ************************************************************
 % VERIFY IF THE LIBRARY WAS CORRECTLY INSTALLED
 % ************************************************************

 % ENTRY: HEX STRING IN THE STACK WITH ADDRESS AND FLASH BANK #

 SAVE

 % WARNING: NO SAFETY CHECKS 

 A=DAT1.A
 D0=A
 D0=D0+10        % SKIP PROLOG & SIZE
 A=DAT0.W
 D1=A
 B=A.W
 P=0
 C=0.S
 C=C-1.S
 ?B=C.S
 GOYES INERAM
 GOSUB MAPFLASH
 GOTO SKPERAM
*INERAM
 GOSBVL ACCESSERAM1

*SKPERAM
 C=DAT1.A  % READ (LIBDATA PROLOG?)
 D=0.S
 LA(5) DOLIB
 ?A#C.A
 GOYES RETNOTFOUND

 D1+10
 A=0.A
 A=DAT1.B
 A=A+A.A
 A=A-1.A   % 5NIBBLES BEFORE ROMID
 CD1EX
 C=C+A.A
 D1=C
 C=DAT1.8
 C=0.A
 B=0.A
 P=7
 ?B=C.WP
 GOYES RETFOUND
*RETNOTFOUND
 D=D+1.S
*RETFOUND
 P=1
 ?B=C.S
 GOYES UNMAPERAM
 GOSUB MAPFLASH
 GOTO SKPUERAM
*UNMAPERAM
 GOSBVL ACCESSERAM1

*SKPUERAM
 P=0
 GOSBVL GETPTR
 D=D-1.S
 GOVLNG "PushT/FLoop"     % RETURN TRUE IF FOUND
 
ENDCODE

* THE ABOVE ASSEMBLER RETURNS TRUE IF INSTALLED, 0 IF ERROR

ITE DROP :: # $11307 ERROROUT ;

;
@