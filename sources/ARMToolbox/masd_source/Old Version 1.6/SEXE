HPHP49-C,*pb::
* * * * * * * * * * * * * * * 
* SçEXE
* Creates a Stand-alone program
* from a string. The generated
* program is fully independent. 
* by Claudio Lapilli
* * * * * * * * * * * * * * *

CK1&Dispatch
 str ::
' ::
CK1&Dispatch
 str :: CKREF
 ' ID $$ARMtmp$$
 xSTO
 GARBAGE
* NOW WORK FROM USEROB (SAFER)
ERRSET
:: ID $$ARMtmp$$ 
CODE
 SAVE
 A=DAT1.A
 D1=A
% *********************************************
% ALIGN THE CODE IF IT IS AN ARM PROGRAM
% *********************************************

*ALIGNOBJECT

% ENTRY: D1=PROLOG OF OBJ
%        R3=ABSOLUTE ADDRESS OF LIBRARY (W/O PROLOG)
%        R4=ACTUAL ADDRESS OF LIBRARY (W/O PROLOG)
% USES: ALL BUT B, D0, R3 AND R4

 D1+5
 C=DAT1.A   % READ SIZE OF LIBDATA OBJECT
 C=C-5.A
 C=C-14.A   % C=SIZE OF ARM PROGRAM
 R0=C.A     % R0=SIZE
 D1+10      % SKIP SIZE AND MARKER
 C=0.A
 C=DAT1.1   % READ OFFSET TO ARM CODE
 AD1EX
 D1=A
 A=A+1.A    % SKIP OFFSET
 ACEX.A
 D=C.A      % D=SAVED SCRATCH AREA
 A=A+C.A    % A=ACTUAL START OF ARM CODE
 R1=A.A     % R1=SAVED ACTUAL ADDR

 C=A.A
 A=A+A.P
 ?A#0.P     % CHECK IF ADDRESS IS WORD ALIGNED
 GOYES MISALIGNED
 GOTO ISALIGNED2
*MISALIGNED
% CODE WAS MISALIGNED, FIX IT
 C=D.A
 C=C+7.A
 LA(1) 8
 C=C&A.P    % C=NEW ALIGNED ADDRESS
 R2=C.A     % R2=SAVED NEW ADDR
 C=C-D.A    % C=OFFSET OF THE RELOCATED CODE
 DAT1=C.P
 A=R2.A     % A=NEW ADDR
 C=R1.A     % C=ORG ADDR
 R1=A.A     % SAVE NEW ADDRESS AS ACTUAL
 ?A<C.A
 GOYES DOMDOWN  % DECIDE IF COPY UP OR DOWN

 CR0EX.A     % C=SIZE OF CODE
 A=A+C.A    % POINT TO END OF BLOCK
 D1=A       % D1=DEST
 A=C.A
 CR0EX.A
 C=C+A.A    % POINT TO END OF BLOCK
 CD0EX    % D0=SOURCE
 R2=C.A     % R2=SAVED D0
 C=R0.A
 GOSBVL MOVEUP
 GOTO ISALIGNED

*DOMDOWN
 D1=A       % D1=DEST
 CD0EX    % D0=SOURCE
 R2=C.A     % R2=SAVED D0
 C=R0.A     % C=SIZE
 GOSBVL MOVEDOWN

*ISALIGNED
 
 C=R2.A
 D0=C       % RESTORE SAVED D0 

*ISALIGNED2

 % ************************************************************
 % FIX RELOCATION TABLES HERE
 % ************************************************************
 
 % ENTRY:
 % R0=SIZE OF ARM CODE
 % R1=ACTUAL START OF CODE

 % MUST PRESERVE D0, B, R3, R4


  A=R1.A
  C=R0.A
  A=A+C.A     % POINT TO END OF CODE
  A=A-8.A     % POINT TO STRUCTURE MARKER
  D1=A
  
  A=0.W
  C=0.W
  A=DAT1.8
  LC(8) $3176B34C
  
  ?A=C.W
  GOYES DOFIXTBL
  GOVLNG GETPTRLOOP  

*DOFIXTBL
  A=0.W
  A=R1.A
  
  ASRB.A      % SAT/2
  P=6
  LA(1) 8
  P=0

*DOADDR

  D1-8
  C=0.W
  C=DAT1.8    % PRIMARY OFFSET
  R1=A.W      % R1=NEW ARM ADDR
  R2=C.W      % KEEP ORIGINAL FOR CALCULATIONS
  DAT1=A.8    % STORE THE ARM ABS ADDRESS
  
  D1-8        % POINT TO PR.ENTRY PT
  A=DAT1.8
  A=A-C.W     % OFFSET 
  C=R1.W
  A=A+C.W     % NEW ADDR
  DAT1=A.8

  D1-16       % POINT TO NUMBER OF ENTRY POINTS

  C=DAT1.A
  D=C.A       % COUNTER
  D1-8

*ENTRYPTLOOP
  ?D#0.A
  GOYES MOREEPT
  GOVLNG GETPTRLOOP
*MOREEPT
  A=DAT1.8    % READ OLD ADDRESS
  C=R2.W      % ORIGINAL ADDR
  A=A-C.W     % CALCULATE OFFSET

  C=R1.W      % NEW ADDR
  A=A+C.W
  DAT1=A.8    % WRITE NEW ARM ADDRESS

  D1-16
  D=D-1.A
  GOTO ENTRYPTLOOP



ENDCODE

CODE
  SAVE
  A=DAT1.A
  D0=A  % D0=>POINTING TO PROLOG OF OBJECT

  D0+5
  C=DAT0.A
  C=C-5.A
  C=C-14.A   % C=SIZE OF ARM PROGRAM
  R0=C.A     % R0=SIZE OF DATA
  D0+10
  C=0.A
  C=DAT0.1   % READ OFFSET TO ARM CODE
  D0+1
  AD0EX
  A=A+C.A    % POINT TO START OF ARM CODE
  R1=A.A     % R1=SAVED ACTUAL ADDR

  GOTO ISALIGNED3
  
*NOSTRUCT
  % LAUNCH FROM START OF CODE
  % WITHOUT RAM

  C=0.W
  C=R1.A  % ACTUAL ARMCODE ADDRESS
  CSRB.A
  % RAM ADDRESS
  P=6
  LC(1) 8
  P=0
  R4=C.W
  GOTO CHECKPASSED

*ISALIGNED3

  A=R1.A     % ACTUAL ARMCODE ADDRESS
  C=R0.A     % SIZE OF CODE
  A=A+C.A
  A=A-8.A    % POINT TO LAST WORD
  D0=A
  C=0.W
  R4=C.W     % ABS ADDRESS OF CODE+RAM REQ
  A=0.W
  C=DAT0.8
  LA(8)  $3176B34C
  ?A#C.W
  GOYES NOSTRUCT
  D0-16
  A=DAT0.8   % READ ADDRESS IN ARM DOMAIN
  D0-16
  C=DAT0.W   % PUT MEMORY REQUIREMENTS IN HIGH WORD
  P=7
  C=A.WP
  P=0
  R4=C.W     % SAVE DATA TO RETURN TO SYSRPL

*CHECKPASSED

  P=0
  GOSBVL GETPTR
  A=R4.W
  P=15
  GOVLNG PUSHhxsLoop
  
ENDCODE

SWAPDROP

CODE
 SAVE
 A=DAT1.A
 D0=A
 D0+10
 A=DAT0.8   % READ ADDRESS
 R1=A.W
 D0+8
 C=DAT0.A   % READ MEMORY REQ.
 D0+5
 A=DAT0.X   % READ FLAGS
 R2=A.X
 ?ABIT=0.2  % GENEATE MMU TABLE?
 GOYES OLDLAUNCH
 GOTO DOMMULAUNCH
*OLDLAUNCH  
 ?ABIT=0.1  % USER PROVIDES RAM
 GOYES ALLOCMEM 
 GOTO GETUSERRAM
*ALLOCMEM
 ?C#0.A
 GOYES DOALLOC
 C=0.W
 B=0.W
 GOTO LAUNCHNOW
*DOALLOC
 C=C+1.A
 GONC NORMALLOC
 % ALLOC ALL MEMORY
 GOSBVL MAKERAM$
 GOTO LAUNCHIT

*NORMALLOC
 C=C+C.A    % CONVERT TO NIBBLES
 RSTK=C
 GOSBVL MAKE$N
 C=RSTK
*LAUNCHIT
 B=0.W
 B=C.A     % ALLOCATED NIBBLES
 C=0.W
 CD0EX
 D0=C
 ?CBIT=1.0
 GOYES SKPALIGN
 C=C+1.A
 B=B-1.A     % 1 NIBBLE LOST
*SKPALIGN
 CSRB.A
 BSRB.A     % SEND B.LO=ALLOC BYTES
 P=6
 LC(1) 8
 P=0        % ARM DOMAIN ADDR
 LA(2) 32
 C=C<A.W
 
*LAUNCHNOW
 P=7
 C=R1.WP   % A.LO=ADDRESS
 P=0
% AT THIS POINT:
%     C.HI=ARM RAM ADDRESS
%     B.LO=RAM SIZE (BYTES)
%     C.LO=ARM JUMP ADDRESS

 ARMSYS  % CALL THE PROGRAM
 GOSBVL GETPTR
 C=R2.X
 ?CBIT=1.1  % IS USER RAM?
 GOYES DONTPUSH
 ?CBIT=0.0  % LEAVE ON STACK?
 GOYES DONTPUSH
 A=R0.A     % GET STR ADDR
 C=DAT1.A
 DAT1=A.A
 D1=D1-5
 DAT1=C.A   % PUSH STRING AND SWAP
 D=D-1.A
*DONTPUSH
 A=DAT0.A
 D0+5
 PC=(A)
 
*GETUSERRAM
 D1+5
 A=DAT1.A
 D0=A
 A=DAT0.A        % READ PROLOG
 
 B=C.A
 LC(5) DOCSTR
 ?C=A.A
 GOYES VALIDRAM
 LC(5) DOHXS
 ?C=A.A
 GOYES VALIDRAM
 LC(5) DOEXT0
 ?C=A.A
 GOYES VALIDRAM

 LC(5) $11301
 GOVLNG GPErrjmpC

*VALIDRAM
 D0+5
 A=DAT0.A
 B=B+B.A    % REQUIRED IN NIBBLES
 B=B+5.A    % PLUS SIZE
 B=B+1.A    % PLUS PADDING
 ?A>=B.A
 GOYES VALIDSIZE

 LC(5) $11302
 GOVLNG GPErrjmpC

*VALIDSIZE
 D0+5       % POINT TO START OF STRING
 GOTO LAUNCHIT

*DOMMULAUNCH
 
%****************************
%* NEW MMU LOADER/LAUNCHER  * 
%* W/VIRTUAL MEMORY PACKER  *
%****************************
% ENTRY:
%       R1.W=ADDRESS TO JUMP
%       C.A = MEMORY REQ.
%       A.X=R2.X=FLAGS

  B=C.A

% ************************
% PORT1 SCAN
% ************************


  P=0
  GOSBVL ACCESSERAM1
  D1=(5) $40000

*ERAMSCAN
  C=DAT1.A
  C=C-1.A
  GOC ENDOFERAM
  D1+5
  C=DAT1.A
  AD1EX
  A=A+C.A
  D1=A
  GOTO ERAMSCAN


*ENDOFERAM
  P=1
  GOSBVL ACCESSERAM1
  P=0
  D1+5    % LEAVE MARKER
  AD1EX
  LC(5) 8191
  A=A+C.A
  A=0.X
  ABIT=0.12   % PAGE ALIGN
  R3=A.A
% R3=FREE ERAM START

% FIND SPACE IN TEMPOB
  D1=(5) RSKTOP
  C=0.W
  C=DAT1.A
  
  C=C+B.A
  C=C+B.A    % LEAVE SPACE AS REQUESTED
  LA(5) 8191
  C=C+A.A
  C=0.X
  CBIT=0.12  % PAGE ALIGN
  D0=C       % MMU TABLE
  R0=C.A     % R0=MMU TBL
  C=C+A.A    % END OF MMU TABLE
  D1=(5) DSKTOP
  A=DAT1.A
  A=A-15.A   % SPACE TO PUSH 3 OBJ
  ?C<A.A
  GOYES ENOUGHRAM
  GOVLNG GPMEMERR % OTHERWISE ERROR
  
*ENOUGHRAM

  ASRB.A
  LA(3) $FFE
  B=A.A      % D=MEM LIMIT
 
  A=0.W
  P=6
  LA(1) 8
  P=0
  A=R0.A
  ASRB.A    % CALC ARM ADDRESS
  LA(3) $FFE
  LC(5) 4096
*MRAMLOOP
  ?A>=B.A
  GOYES MRAMDONE
  DAT0=A.8
  D0+8
  A=A+C.A
  GOTO MRAMLOOP
*MRAMDONE

  
  % ADD FREE ERAM
  A=R3.A
  ASRB.A    % CALC ARM ADDRESS
  LA(3) $FFE
  LC(5) $40FFE
  B=C.A
  LC(5) 4096
*ERAMLOOP
  ?A>=B.A
  GOYES ERAMDONE
  DAT0=A.8
  D0+8
  A=A+C.A
  GOTO ERAMLOOP
*ERAMDONE
  
  A=0.W
  DAT0=A.8   % MARK END OF MMU

  % HERE: D0=END OF MMU TABLE
  % R0=START OF MMU TABLE
  % R1=ADDRESS OF EXECUTABLE
  
  % CALC NUMBER OF 4K PAGES
  C=0.W
  CD0EX
  A=R0.A
  C=C-A.A
  C=C+C.A
  CSR.A
  B=C.W     % B=NUMBER OF PAGES
  LA(5) 4   % MINIMUM TO RUN=4 PAGES
  ?B>A.A
  GOYES ENOUGHPAGES
  GOVLNG GPMEMERR
*ENOUGHPAGES

  A=R2.X
  ?ABIT=1.3
  GOYES USESYSRAM
*FINALLAUNCH
  C=R0.A
  P=7
  CSRB.WP
  P=6
  LC(1) 8
  P=0
  LA(5) 32
  C=C<A.W   % C.HI=MMU ADDRESS
  P=7
  C=R1.WP   % C.LO=JMP ADDR
  P=0
  ARMSYS
% RETURN IMMEDIATELY
  GOVLNG GETPTRLOOP
  
*USESYSRAM
  GOSUB SKIPARMCODE

NIBHEX FFF5D29E0292195E4195195E5014280E
NIBHEX CB02F95E0000253E320000A0420000BE
NIBHEX 0000053E10B2242E9FFFFFA000010A1E
NIBHEX 520000BE1092242ED10000BE0000053E
NIBHEX 910000A000060A1E2001080EFFE1183E
NIBHEX F0011C3EE001182E10A2082E1002242E
NIBHEX FFE2283EF0022C3EE002282E4004442E
NIBHEX 1000251E300000AA40024A5E10A2282E
NIBHEX 1005582E9FFFFFAE4001D95E4195185E
NIBHEX 00020A3E4002485E8196185E4302F95E
NIBHEX C192185EFFF5DB8EC19F195E4001D95E
NIBHEX 9FFFFFAE20A10A3E9C000A3EEFF5D29E
NIBHEX 000EF82E000000FEEFF9DB8E56000A3E
NIBHEX 9FFFFFAE000E1000
  
  
*SKIPARMCODE
  A=PC
  A=A-4.A
  C=RSTK
  D0=C
  A=A-C.A
  R2=A.A
  A=R0.A
  LC(5) 2048
  A=A+C.A
  D1=A
  D=A.A
  C=R2.A
  MOVEDN
  A=R1.W
  DAT1=A.8   % STORE JMP ADDR
  C=0.W
  C=D.A
  CSRB.A
  P=6
  LC(1) 8
  P=0
  R1=C.W
  GOTO FINALLAUNCH  
  
ENDCODE

 ;
ERRTRAP :: ' ID $$ARMtmp$$ PURGE ERRJMP ;

DROP
' ID $$ARMtmp$$ xPURGE
;



;
2 ::N


;

;
@