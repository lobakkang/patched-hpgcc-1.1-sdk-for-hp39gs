HPHP49-C,*0P::

*****************************************************
* LibLink: OBTAIN A COPY OF THE ENTRY PT TABLE
*               By Claudio Lapilli
*               ENTRY: XLIB on the stack
*               RETURN: HXS on the stack with data
*                       to launch the program
*****************************************************

CK1

DUPTYPEROMP? NcaseTYPEERR

CODE
  SAVE
  A=DAT1.A
  D0=A
  D0+5
  A=DAT0.3       % READ ROMID
  D0+3
  C=0.A
  C=DAT0.3       % READ ROMP NUMBER
  R4=C.A         % SAVE IN R4
  D1=(5) $8611D
  C=DAT1.3
  D=C.X          % COUNT IN THE TABLE
  D1+3           % POINT TO FIRST ENTRY

*FINDLIB
  D=D-1.X
  GOC NOTFOUND
  C=DAT1.3       % SEARCH ROMID IN ROMPART TABLE
  ?C=A.X
  GOYES FOUNDLIB
  D1+16
  GOTO FINDLIB
*NOTFOUND
  LC(5) $11303
  GOVLNG GPErrjmpC
*FOUNDLIB
  D1+3
  C=DAT1.A       % ADDRESS OF LIBRARY, POINTING TO ROMID
  R0=C.A
  D1+5
  C=DAT1.A       % SWITCHING ROUTINE
  R2=C.A

  % IDENTIFY WHICH BANK IS
  B=0.S
  B=B-1.S        % IN RAM BY DEFAULT
  ?C=0.A
  GOYES NORMALRAM
  
  D1=(5) ACCESSBank8+2
  P=0
*BNKLOOP
  A=DAT1.A
  ?A=C.A
  GOYES ISBANK
  D1+7
  P+1
  ?P#6
  GOYES BNKLOOP
  
  % OTHERWISE IT HAS TO BE ERAM
  P=0
  GOTO NORMALRAM
*ISBANK
  C=P.15
  P=0
  B=C.S         % BANK NUMBER IN B.S
  
*NORMALRAM  
  GOSUB MAPMEMORY

  C=R0.A        % LIBRARY ADDR
  D1=C
  D1+13         % POINT TO LINK TABLE OFFSET
  A=DAT1.A
  CD1EX
  C=C+A.A       % POINT TO START OF LINK TABLE
  C=C+10.A      % SKIP PROLOG+SIZE
  A=R4.A
  C=C+A.A
  A=A+A.A
  A=A+A.A
  C=C+A.A       % ADD 5*ROMP NUMBER
  CD1EX
  A=DAT1.A
  CD1EX
  C=C+A.A
  CD0EX         % D0=>POINTING TO PROLOG OF OBJECT

  % CHECK IF VALID ARM PROGRAM

  A=DAT0.A
  LC(5) DOEXT0
  ?C=A.A
  GOYES ISLIBDATA
  LC(5) DOHXS
  ?C=A.A
  GOYES ISLIBDATA
  LC(5) DOCSTR
  ?C=A.A
  GOYES ISLIBDATA
*INVALIDPROG  
  GOSUB UNMAPMEM       % UNMAP MEMORY BEFORE RETURNING
  LC(5) $11304
  GOVLNG GPErrjmpC

*ISLIBDATA
  D0+5
  C=DAT0.A
  C=C-5.A
  C=C-14.A   % C=SIZE OF ARM PROGRAM
  R0=C.A     % R0=SIZE OF DATA
  D0+5
  C=DAT0.8   % READ FIRST WORD
  LA(5) $0B34C
  ?C#A.A     % IF STARTS WITH \\\"L\\179\\\" IS VALID
  GOYES INVALIDPROG

  D0+5
  C=0.A
  C=DAT0.1   % READ OFFSET TO ARM CODE
  D0+1
  AD0EX
  A=A+C.A    % POINT TO START OF ARM CODE
  R1=A.A     % R1=SAVED ACTUAL ADDR
  A=A+A.P
  ?A=0.P     % CHECK IF ADDRESS IS WORD ALIGNED
  GOYES ISALIGNED

% CODE WAS MISALIGNED, ERROR
  GOSUB UNMAPMEM       % UNMAP MEMORY BEFORE RETURNING
  LC(5) $11305
  GOVLNG GPErrjmpC

*NOSTRUCT

  GOSUB UNMAPMEM       % UNMAP MEMORY BEFORE RETURNING
  LC(5) $11306
  GOVLNG GPErrjmpC

*ISALIGNED

  A=R1.A     % ACTUAL ARMCODE ADDRESS
  C=R0.A     % SIZE OF CODE
  A=A+C.A
  A=A-8.A    % POINT TO LAST WORD
  D0=A
  C=0.W
  R4=C.W     % ABS ADDRESS OF CODE+RAM REQ
  A=0.W
  C=DAT0.8
  LA(8)  $3176B34C
  ?A#C.W
  GOYES NOSTRUCT
  D0-8
  A=DAT0.8
  R4=A.W
%  D1=(5) SavMisc+3   % USE TEMPORARY MEM TO RUN AN ARM PROGRAM
%  LC(8) $E92D5FFF
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E591290C
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E5922000
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E581290C
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E8BD9FFF
%  DAT1=C.8

  % ONE MORE SAFETY CHECK
%  C=0.W
%  CD0EX
%  D0=C
%  A=R1.A
%  C=C-A.A      % GET OFFSET FROM START OF CODE
%  CSRB.A       % OFFSET IN BYTES
%  A=R4.W       % ARM DOMAIN START OF CODE
%  P=7
%  A=A+C.WP     % ARM DOMAIN POINTER TO ABSOLUTE ADDRESS
%  P=0
%  LC(5) SavMisc+3
%  ARMSAT       % GET ABSOULTE ADDRESS FROM ARM DOMAIN
%  P=7
%  C=R4.WP
%  ?A=C.WP
%  GOYES CHECKPASSED
  
%  P=0
%  LC(5) $11306   % ERROR IF INCONSISTENCY BETWEEN DOMAINS
%  GOVLNG GPErrjmpC
  
*CHECKPASSED
  D0-16
  D0-8
% D0->NUMBER OF ENTRIES
  CD0EX
  D0=C
  R4=C.A     % SAVE D0
  A=DAT0.8
  C=A.A
  CSL.A
  C=C+10.A  % 8=NUMBER OF E.P.+2=PADDING
  C=C+10.A  % PROLOG+SIZE

  GOSBVL CREATETEMP
  GONC SKPMEMORYERR
  GOSUB UNMAPMEM
  GOVLNG GPMEMERR
*SKPMEMORYERR

  AD0EX
  B=A.A
  D0=A

  LC(5) DOHXS
  DAT0=C.A
  D0+5
  CD1EX
  AD0EX
  D0=A
  C=C-A.A    % NIBBLES OF HXSTR
  DAT0=C.A   % STORE SIZE
  D0+5
  A=R4.A
  D1=A
  A=DAT1.8
  DAT0=A.8   % COPY NUMBER OF E.P.
  D1-8
  D0+8
*COPYTBL
  ?A=0.A
  GOYES ENDCOPY
  C=DAT1.8
  DAT0=C.8
  D1-8
  D0+8
  C=DAT1.8
  DAT0=C.8
  D1-8
  D0+8  
  A=A-1.A
  GOTO COPYTBL
*ENDCOPY
  A=B.A
  R4=A.A
  
  GOSUB UNMAPMEM
  P=0
  GOSBVL GETPTR
  A=R4.A
  GOVLNG PUSHA
  

*MAPMEMORY
  A=R2.A        % R2 = SWITCHING ROUTINE
  ?A=0.A        % A=SWITCHING ROUTINE ADDRESS
  RTNYES        % DONT SWITCH IF NO ROUTINE
  P=0
  PC=A          % JUMP TO SWITCHING ROUTINE
*UNMAPMEM
  A=R2.A        % R2 = SWITCHING ROUTINE
  ?A=0.A        % A=SWITCHING ROUTINE ADDRESS
  RTNYES        % DONT SWITCH IF NO ROUTINE
  P=1
  PC=A          % JUMP TO SWITCHING ROUTINE
  
ENDCODE
SWAPDROP
;
@