HPHP49-C,*pA::

*****************************************************
* PrgLink: OBTAIN A POINTER TO AN ARM LIBRARY
*               By Claudio Lapilli
*               ENTRY: XLIB on the stack
*               RETURN: HXS on the stack with data
*                       to launch the program
*****************************************************

CK1

DUPTYPEROMP? NcaseTYPEERR

CODE
  SAVE
  A=DAT1.A
  D0=A
  D0+5
  A=DAT0.3       % READ ROMID
  D0+3
  C=0.A
  C=DAT0.3       % READ ROMP NUMBER
  R4=C.A         % SAVE IN R4
  D1=(5) $8611D
  C=DAT1.3
  D=C.X          % COUNT IN THE TABLE
  D1+3           % POINT TO FIRST ENTRY

*FINDLIB
  D=D-1.X
  GOC NOTFOUND
  C=DAT1.3       % SEARCH ROMID IN ROMPART TABLE
  ?C=A.X
  GOYES FOUNDLIB
  D1+16
  GOTO FINDLIB
*NOTFOUND
  LC(5) $11303
  GOVLNG GPErrjmpC
*FOUNDLIB
  D1+3
  C=DAT1.A       % ADDRESS OF LIBRARY, POINTING TO ROMID
  R0=C.A
  D1+5
  C=DAT1.A       % SWITCHING ROUTINE
  R2=C.A

  % IDENTIFY WHICH BANK IS
  B=0.S
  B=B-1.S        % IN RAM BY DEFAULT
  ?C=0.A
  GOYES NORMALRAM
  
  D1=(5) ACCESSBank8+2
  P=0
*BNKLOOP
  A=DAT1.A
  ?A=C.A
  GOYES ISBANK
  D1+7
  P+1
  ?P#6
  GOYES BNKLOOP
  
  % OTHERWISE IT HAS TO BE ERAM
  P=0
  GOTO NORMALRAM
*ISBANK
  C=P.15
  P=0
  B=C.S         % BANK NUMBER IN B.S
  
*NORMALRAM  
  GOSUB MAPMEMORY

  C=R0.A        % LIBRARY ADDR
  D1=C
  D1+13         % POINT TO LINK TABLE OFFSET
  A=DAT1.A
  CD1EX
  C=C+A.A       % POINT TO START OF LINK TABLE
  C=C+10.A      % SKIP PROLOG+SIZE
  A=R4.A
  C=C+A.A
  A=A+A.A
  A=A+A.A
  C=C+A.A       % ADD 5*ROMP NUMBER
  CD1EX
  A=DAT1.A
  CD1EX
  C=C+A.A
  CD0EX         % D0=>POINTING TO PROLOG OF OBJECT

  % CHECK IF VALID ARM PROGRAM

  A=DAT0.A
  LC(5) DOEXT0
  ?C=A.A
  GOYES ISLIBDATA
  LC(5) DOHXS
  ?C=A.A
  GOYES ISLIBDATA
  LC(5) DOCSTR
  ?C=A.A
  GOYES ISLIBDATA
*INVALIDPROG  
  GOSUB UNMAPMEM       % UNMAP MEMORY BEFORE RETURNING
  LC(5) $11304
  GOVLNG GPErrjmpC

*ISLIBDATA
  D0+5
  C=DAT0.A
  C=C-5.A
  C=C-14.A   % C=SIZE OF ARM PROGRAM
  R0=C.A     % R0=SIZE OF DATA
  D0+5
  C=DAT0.8   % READ FIRST WORD
  LA(5) $0B34C
  ?C#A.A     % IF STARTS WITH \\\"L\\179\\\" IS VALID
  GOYES INVALIDPROG

  D0+5
  C=0.A
  C=DAT0.1   % READ OFFSET TO ARM CODE
  D0+1
  AD0EX
  A=A+C.A    % POINT TO START OF ARM CODE
  R1=A.A     % R1=SAVED ACTUAL ADDR
  A=A+A.P
  ?A=0.P     % CHECK IF ADDRESS IS WORD ALIGNED
  GOYES ISALIGNED

% CODE WAS MISALIGNED, ERROR
  GOSUB UNMAPMEM       % UNMAP MEMORY BEFORE RETURNING
  LC(5) $11305
  GOVLNG GPErrjmpC

*NOSTRUCT
  % LAUNCH FROM START OF CODE
  % WITHOUT RAM

  C=0.W
  C=R1.A  % ACTUAL ARMCODE ADDRESS
  CSRB.A
  C=B.S
  C=C+1.S
  GONC INFLASHMEM

  % RAM ADDRESS
  P=6
  LC(1) 8
  P=0
  R4=C.W
  GOTO CHECKPASSED

*INFLASHMEM
  A=C.A
  C=0.A
  P=C.15
  C=P.4
  C=C+C.A     % 0x20000 * (nBANKS+1)
  C=C+A.A
  P=5
  LC(1) 1
  P=0        % C=ARM DOMAIN ADDRESS
  C=0.S
  R4=C.W
  GOTO CHECKPASSED

*ISALIGNED

  A=R1.A     % ACTUAL ARMCODE ADDRESS
  C=R0.A     % SIZE OF CODE
  A=A+C.A
  A=A-8.A    % POINT TO LAST WORD
  D0=A
  C=0.W
  R4=C.W     % ABS ADDRESS OF CODE+RAM REQ
  A=0.W
  C=DAT0.8
  LA(8)  $3176B34C
  ?A#C.W
  GOYES NOSTRUCT
  D0-16
  A=DAT0.8   % READ ADDRESS IN ARM DOMAIN
  D0-16
  C=DAT0.W   % PUT MEMORY REQUIREMENTS IN HIGH WORD
  P=7
  C=A.WP
  P=0
  R4=C.W     % SAVE DATA TO RETURN TO SYSRPL

%  D1=(5) SavMisc+3   % USE TEMPORARY MEM TO RUN AN ARM PROGRAM
%  LC(8) $E92D4FFF
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E591490C
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E5944000
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E581490C
%  DAT1=C.8
%  D1=D1+8
%  LC(8) $E8BD8FFF
%  DAT1=C.8

  % ONE MORE SAFETY CHECK
%  D0+16         % POINT TO THE ABSOLUTE ADDRESS
%  C=0.W
%  CD0EX
%  D0=C
%  A=R1.A
%  C=C-A.A      % GET OFFSET FROM START OF CODE
%  CSRB.A       % OFFSET IN BYTES
%  A=R4.W       % ARM DOMAIN START OF CODE
%  P=7
%  A=A+C.WP     % ARM DOMAIN POINTER TO ABSOLUTE ADDRESS
%  P=0
%  LC(5) SavMisc+3
%  ARMSAT       % GET ABSOULTE ADDRESS FROM ARM DOMAIN
%  P=7
%  C=R4.WP
%  ?A=C.WP
%  GOYES CHECKPASSED

%  GOSUB UNMAPMEM
%  P=0
%  LC(5) $11306   % ERROR IF INCONSISTENCY BETWEEN DOMAINS
%  GOVLNG GPErrjmpC
  
*CHECKPASSED

  GOSUB UNMAPMEM
  P=0
  GOSBVL GETPTR
  A=R4.W
  P=15
  GOVLNG PUSHhxsLoop
  
   

*MAPMEMORY
  A=R2.A        % R2 = SWITCHING ROUTINE
  ?A=0.A        % A=SWITCHING ROUTINE ADDRESS
  RTNYES        % DONT SWITCH IF NO ROUTINE
  P=0
  PC=A          % JUMP TO SWITCHING ROUTINE
*UNMAPMEM
  A=R2.A        % R2 = SWITCHING ROUTINE
  ?A=0.A        % A=SWITCHING ROUTINE ADDRESS
  RTNYES        % DONT SWITCH IF NO ROUTINE
  P=1
  PC=A          % JUMP TO SWITCHING ROUTINE
  

ENDCODE
SWAPDROP
;
@