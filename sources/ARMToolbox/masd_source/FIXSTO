HPHP49-C,*G::

*****************************************************
* FIXSTO: FIXES AN ARM LIBRARY AND STORES THE LIBRARY
*         FOR PERMANENT USE
*         By Claudio Lapilli
*****************************************************

CK2
DUPTYPETAG? IT :: DUP TAG>_ DROP TYPEIDNT? ?SKIP :: #1130B ERROROUT ;
CODE
SAVE
A=DAT1.A
D1=A
D1+5
GOSBVL "ValidPortTag?"
GOVLNG "GPPushT/FLp"
ENDCODE

case :: #1130B ERROROUT ;

* CONVERT INTO BACKUP OBJECT
TAG>_
UNROT
ID>$
"0" &$
TAGOBS
ONE
TWO
{}N
OB>BAKcode
SWAP
xNUM
%48. %-
  ;


DUPTYPEZINT? ITE :: FPTR2 ^Z>R ;
:: DUPTYPEREAL? NcaseTYPEERR ;
 COERCE
 DUP 2 #> ?SEMI

 SWAP

* THIS IS (DUPTYPELIB?)
PTR $35064 OVER TYPEBAK?_ OR NcaseTYPEERR

* MAKE SURE LIBRARY IS IN TEMPOB BEFORE WE STORE IT
CKREF

SWAP


CODE
 SAVE
 A=DAT1.A
 A+5.A
 D0=A      % D0 = BINT
 A=DAT0.S       % READ PORT NUMBER FROM STACK
 D1+5
 A=DAT1.A
 A+5.A
 D0=A           % D0 = PTR TO SIZE OF LIBRARY
 R4=A.A         % SAVE POINTER TO SIZE

% *********************************************
% FIND AN ADDRESS IN PORT MEMORY WHERE THIS
% LIBRARY WILL BE STORED
% *********************************************
 
% ENTRY: A.S = PORT# , D0->SIZE OF LIB

  A-1.S
  GONC SKPP0
  GOTO ISPORT0
*SKPP0
  A-1.S
  GONC SKPP1
  GOTO ISPORT1
*SKPP1

% ************************
% PORT2 SCANNING
% ************************

  A=DAT0.A
  A=A+15.A    % ADD LIB PROLOG + ADDITIONAL FLASH DATA + 2 FREE NIBBLES
  B=A.A       % B=REQUIRED MINIMUM SIZE

  B=0.S   % START WITH FIRST USER FLASH BANK

  B=B+5.S % FROM TOP TO BOTTOM
  D=0.S
  D=D-1.S  % INVALID BANK
  D=0.A
  D=D-1.A  % MAX FREE MEM
*GETFREEMEM
 P=8
 GOSUB MAPFLASH
 C=A.A
 ?B>A.A
 GOYES NOTTHISONE
 ?D<=C.A
 GOYES NOTTHISONE
 D=A.A
 D=B.S  % CURRENT BANK PICK
*NOTTHISONE
 B=B-1.S
 GONC GETFREEMEM

% HERE: D.S=BANK TO USE

  B=D.S
  D=D+1.S
  GONC SCANFLASHLOOP
  GOVLNG GPMEMERR
*SCANFLASHLOOP
  P=0
  GOSUB MAPFLASH
  D1=(5) $4020A

*FLSHSCAN
  C=DAT1.B
  C=C+1.B
  GOC ENDOFBANK
  D1+2
  C=DAT1.A
  AD1EX
  A=A+C.A
  D1=A
  GOTO FLSHSCAN


*ENDOFBANK
  P=1
  GOSUB MAPFLASH
  P=0
  AD1EX
  D1=A
  GOTO FOUNDITFLSH
  

% MAPS A FLASH BANK IN B.S
% STARTS FROM BANK8
% P=0 -> MAP
% P=1 -> UNMAP 
% P=8 -> GET FREE MEM

*MAPFLASH
  C=0.A
  C=B.S
  CPEX.15
  CPEX.0   % P=0, C.0=BANK NUMBER
  LA(5) ACCESSBank8

  % EACH ROUTINE TAKES 7 NIBBLES
  A=A+C.A
  C=C+C.A
  A=A+C.A
  C=C+C.A
  A=A+C.A   % A=A+7*C

  CPEX.15
  PC=A       % JUMP TO THE MAPPING ROUTINE


*ISPORT1


% ************************
% PORT1 SCANNING
% ************************

  A=DAT0.A
  A=A+10.A    % ADD LIB PROLOG + 5 FREE NIBBLES
  B=A.A       % B=REQUIRED MINIMUM SIZE



  B=0.S   
  B=B-1.S     % MARK THAT IF B.S=F --> ERAM

  P=0
  GOSBVL ACCESSERAM1
  D1=(5) $40000

*ERAMSCAN
  C=DAT1.A
  C=C-1.A
  GOC ENDOFERAM
  D1+5
  C=DAT1.A
  AD1EX
  A=A+C.A
  D1=A
  GOTO ERAMSCAN


*ENDOFERAM
  P=1
  GOSBVL ACCESSERAM1
  P=0
  AD1EX
  D1=A
  A=A+B.A
  LC(5) $7F000
  ?A<C.A
  GOYES FOUNDIT

  GOVLNG GPMEMERR        % INSUFFICIENT MEMORY ERROR




*ISPORT0
% ************************
% PORT0 SCANNING
% ************************

  A=DAT0.A
  A=A+5.A    % ADD LIB PROLOG + 5 FREE NIBBLES
  B=A.A       % B=REQUIRED MINIMUM SIZE



  B=0.S   
  B=B-1.S    
  B=B-1.S     % MARK B.S=E --> PORT0

  D1=(5) ROMPARTS
  C=DAT1.A
  C=C-B.A
  D1=C
  GOTO FOUNDIT
  
  
*FOUNDITFLSH
  D1+8   % SKIP ADDITIONAL FLASH INFO

*FOUNDIT

  % D1 -> ABSOLUTE ADDRESS WHERE THE LIBRARY WILL BE STORED
  % B.S = FLASH BANK WHERE IT WILL BE STORED - 8 (F=ERAM,E=PORT0)
  AD1EX
  A+5.A   % POINT TO THE SIZE OF THE LIBRARY (SAME AS R4)
  R3=A.A  % SAVE FUTURE ADDRESS FOR ALIGNMENT
  A=R4.A
  D0=A    % RESTORE D0->SIZE
  D0-5
  A=DAT0.A
  D0+5
  D=0.S   % MARK THIS IS A LIBRARY
  LC(5) DOBAK
  ?C#A.A
  GOYES ISALIBRARY
  D=D-1.S % MARK THIS IS A BACKUP
*ISALIBRARY
% *********************************************
% FIND ARM CODE WITHIN THE LIBRARY
% *********************************************

% B.S = FLASH BANK NUMBER
% D.S = ISBACKUP?
% R3 = FINAL ADDRESS (W/O PROLOG)
% R4 = ACTUAL ADDRESS (W/O PROLOG)


 D0+5
 C=0.A
 C=DAT0.B       % LENGTH OF TITLE
 D0+2
 ?C=0.B
 GOYES NOSKPTITLE
 AD0EX
 A+C.A
 A+C.A
 A+2.A
 AD0EX

% D0 POINTS AFTER THE TITLE
*NOSKPTITLE

 ?D=0.S
 GOYES SCANLIB

 CD0EX
 D0=C
 D1=C   % D1->PROLOG OF OBJECT
 
 GOSUB ALIGNOBJECT

 GOTO DONEALIGN

*SCANLIB
 D0+13        % SKIP ROMID (3) + HASH PTR (5) + MESS PTR (5)
 C=DAT0.A     % READ LINK TABLE PTR
 AD0EX
 A+C.A
 A+5.A        % SKIP PROLOG OF HASH TABLE
 D0=A
 A=DAT0.A
 A-5.A        % A=5*NUMBER OF XLIB'S TO SCAN
 B=A.A
 D0+5

*ALIGNXLIB
 ?B=0.A
 GOYES DONEALIGN
 A=DAT0.A
 CD0EX
 A=A+C.A
 CD0EX
 D1=A

 % D1 -> PROLOG OF OBJECT TO ALIGN
 % MUST PRESERVE B (COUNTER),D0, R3 AND R4

 GOSUB ALIGNOBJECT

 B=B-5.A
 D0+5
 GOTO ALIGNXLIB

*DONEALIGN

% NOW FIX THE CRC OF THE LIBRARY


 A=R4.A
 D0=A
 A=DAT0.A
 A=A-4.A
 GOSBVL DoCRC
 DAT0=A.4

 
% DONE, RETURN SOME RESULTS TO SYSRPL FOR CHECKS

 C=0.W
 P=3
 C=A.WP
 P=0
 A=0.W
 LA(2) 20
 C=C<A.W
 C=R3.A
 C=B.S
 R0=C.W

 GOSBVL GETPTR

 A=R0.W  % SAVE LIBRARY CRC
 P=15
 GOVLNG PUSHhxsLoop




% *********************************************
% ALIGN THE CODE IF IT IS AN ARM PROGRAM
% *********************************************

*ALIGNOBJECT

% ENTRY: D1=PROLOG OF OBJ
%        R3=ABSOLUTE ADDRESS OF LIBRARY (W/O PROLOG)
%        R4=ACTUAL ADDRESS OF LIBRARY (W/O PROLOG)
% USES: ALL BUT B, D0, R3 AND R4

 A=DAT1.A
 LC(5) DOEXT0
 ?C=A.A
 GOYES ISLIBDATA
 LC(5) DOCODE
 ?C=A.A
 GOYES ISLIBDATA
 LC(5) DOHXS
 ?C=A.A
 GOYES ISLIBDATA
 LC(5) DOCSTR
 ?C#A.A
 RTNYES       % IT'S NOT AN ARM PROGRAM

*ISLIBDATA
 D1+10
 C=DAT1.A   % READ HEADER
 LA(5) $0B34C
 ?C#A.A     % IF STARTS WITH \\\\\\\"L\\\\179\\\\\\\" IS VALID
 RTNYES     % NOT AN ARM V3 PROGRAM

 D1-5       % POINT TO OBJECT SIZE
 C=DAT1.A   % READ SIZE OF LIBDATA OBJECT
 C=C-5.A
 C=C-14.A   % C=SIZE OF ARM PROGRAM
 R0=C.A     % R0=SIZE
 D1+10      % SKIP SIZE AND MARKER
 C=0.A
 C=DAT1.1   % READ OFFSET TO ARM CODE
 AD1EX
 D1=A
 A=A+1.A    % SKIP OFFSET
 ACEX.A
 D=C.A      % D=SAVED SCRATCH AREA
 A=A+C.A    % A=ACTUAL START OF ARM CODE
 R1=A.A     % R1=SAVED ACTUAL ADDR

 C=R4.A
 A=A-C.A    % CALC OFFSET WITHIN LIBRARY
 C=R3.A
 A=A+C.A    % ABS FINAL ADDRESS
 C=A.A
 A=A+A.P
 ?A#0.P     % CHECK IF ADDRESS IS WORD ALIGNED
 GOYES MISALIGNED
 GOTO ISALIGNED2
*MISALIGNED
% CODE WAS MISALIGNED, FIX IT
 C=D.A
 A=R4.A
 C=C-A.A
 A=R3.A
 C=C+A.A    % C=ABS ADDRESS
 C=C+7.A
 LA(1) 8
 C=C&A.P    % C=NEW ALIGNED ADDRESS
 A=R3.A
 C=C-A.A    % OFFSET
 A=R4.A
 C=C+A.A    % NEW ADDRESS IN RAM
 R2=C.A     % R2=SAVED NEW ADDR
 C=C-D.A    % C=OFFSET OF THE RELOCATED CODE
 DAT1=C.P
 A=R2.A     % A=NEW ADDR
 C=R1.A     % C=ORG ADDR
 R1=A.A     % SAVE NEW ADDRESS AS ACTUAL
 ?A<C.A
 GOYES DOMDOWN  % DECIDE IF COPY UP OR DOWN

 CR0EX.A     % C=SIZE OF CODE
 A=A+C.A    % POINT TO END OF BLOCK
 D1=A       % D1=DEST
 A=C.A
 CR0EX.A
 C=C+A.A    % POINT TO END OF BLOCK
 CD0EX    % D0=SOURCE
 R2=C.A     % R2=SAVED D0
 C=R0.A
 GOSBVL MOVEUP
 GOTO ISALIGNED

*DOMDOWN
 D1=A       % D1=DEST
 CD0EX    % D0=SOURCE
 R2=C.A     % R2=SAVED D0
 C=R0.A     % C=SIZE
 GOSBVL MOVEDOWN

*ISALIGNED
 
 C=R2.A
 D0=C       % RESTORE SAVED D0 

*ISALIGNED2

 RTN   




ENDCODE


* CONTINUE FROM RPL

UNROT
UNCOERCE

* STORE THE FIXED LIBRARY AS USUAL
ERRSET xSTO 
ERRTRAP :: 3DROP CK0 ERRJMP ;

CODE

 % ************************************************************
 % VERIFY IF THE LIBRARY WAS CORRECTLY INSTALLED
 % ************************************************************

 % ENTRY: HEX STRING IN THE STACK WITH ADDRESS AND FLASH BANK #

 SAVE

 % WARNING: NO SAFETY CHECKS 

 A=DAT1.A
 D0=A
 D0=D0+10        % SKIP PROLOG & SIZE
 A=DAT0.W
 D1=A
 B=A.W
 P=0
 C=0.S
 C=C-1.S
 ?B=C.S
 GOYES INERAM
 C=C-1.S
 ?B=C.S
 GOYES SKPERAM
 GOSUB MAPFLASH
 GOTO SKPERAM
*INERAM
 GOSBVL ACCESSERAM1

*SKPERAM
 C=DAT1.A  % READ LIBDATA SIZE
 AD1EX
 A=A+C.A
 AD1EX
 D1-4     % POINT TO LIB CRC
 C=0.A
 C=DAT1.4
 A=0.W
 LA(2) 20
 P=8
 B=B>A.WP
 P=0
 D=0.S
 ?B=C.A
 GOYES RETFOUND

*RETNOTFOUND
 D=D+1.S
*RETFOUND
 P=1
 C=0.S
 C=C-1.S
 ?B=C.S
 GOYES UNMAPERAM
 C=C-1.S
 ?B=C.S
 GOYES SKPUERAM
 GOSUB MAPFLASH
 GOTO SKPUERAM
*UNMAPERAM
 GOSBVL ACCESSERAM1

*SKPUERAM
 P=0
 GOSBVL GETPTR
 D=D-1.S
 GOVLNG "PushT/FLoop"     % RETURN TRUE IF FOUND
 
ENDCODE

* THE ABOVE ASSEMBLER RETURNS TRUE IF INSTALLED, 0 IF ERROR

ITE DROP :: DROP CK0 # $11307 ERROROUT ;

;
@