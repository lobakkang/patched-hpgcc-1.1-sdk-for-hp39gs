<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>GGL: ggl.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>ggl.h</h1><a href="ggl_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 <span class="comment">//&amp; ****************************************************************************</span>
00002 <span class="comment">//&amp;</span>
00003 <span class="comment">//&amp; Copyright (C) 2004 HP-GCC Team</span>
00004 <span class="comment">//&amp;</span>
00005 <span class="comment">//&amp; ****************************************************************************</span>
00006 <span class="comment">//&amp;</span>
00007 <span class="comment">//&amp; This file is part of HP-GCC.</span>
00008 <span class="comment">//&amp;</span>
00009 <span class="comment">//&amp; HP-GCC is free software; you can redistribute it and/or modify</span>
00010 <span class="comment">//&amp; it under the terms of the GNU General Public License as published by</span>
00011 <span class="comment">//&amp; the Free Software Foundation; either version 2, or (at your option)</span>
00012 <span class="comment">//&amp; any later version.</span>
00013 <span class="comment">//&amp; </span>
00014 <span class="comment">//&amp; HP-GCC is distributed in the hope that it will be useful,</span>
00015 <span class="comment">//&amp; but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00016 <span class="comment">//&amp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00017 <span class="comment">//&amp; GNU General Public License for more details.</span>
00018 <span class="comment">//&amp; </span>
00019 <span class="comment">//&amp; You should have received a copy of the GNU General Public License</span>
00020 <span class="comment">//&amp; along with HP-GCC; see the file COPYING. </span>
00021 <span class="comment">//&amp; </span>
00022 <span class="comment">//&amp; As a special exception, you may use this file as part of a free software</span>
00023 <span class="comment">//&amp; library without restriction.  Specifically, if other files instantiate</span>
00024 <span class="comment">//&amp; templates or use macros or inline functions from this file, or you compile</span>
00025 <span class="comment">//&amp; this file and link it with other files to produce an executable, this</span>
00026 <span class="comment">//&amp; file does not by itself cause the resulting executable to be covered by</span>
00027 <span class="comment">//&amp; the GNU General Public License.  This exception does not however</span>
00028 <span class="comment">//&amp; invalidate any other reasons why the executable file might be covered by</span>
00029 <span class="comment">//&amp; the GNU General Public License.</span>
00030 <span class="comment">//&amp;</span>
00031 <span class="comment">//&amp; ****************************************************************************</span>
00032 
<a name="l00067"></a><a class="code" href="ggl_8h.html#a0">00067</a> <span class="preprocessor">#define STATEBUFSIZE ((11+6)*4)</span>
00068 <span class="preprocessor"></span>
<a name="l00072"></a><a class="code" href="ggl_8h.html#a1">00072</a> <span class="preprocessor">#define LCD_H 80</span>
00073 <span class="preprocessor"></span>
<a name="l00077"></a><a class="code" href="ggl_8h.html#a2">00077</a> <span class="preprocessor">#define LCD_W 160</span>
00078 <span class="preprocessor"></span>
<a name="l00087"></a><a class="code" href="ggl_8h.html#a3">00087</a> <span class="preprocessor">#define SCREENBUFSIZE ((LCD_W&gt;&gt;2)*(LCD_H)*2)</span>
00088 <span class="preprocessor"></span>
00089 <span class="comment">// data types/structures</span>
00090 
00091 <span class="comment">// surface used for bitblt operations</span>
00092 <span class="comment">// notes:</span>
00093 <span class="comment">// a surface is infinite in both width and height, there are no memory limits</span>
00094 <span class="comment">// .addr must be a word aligned address</span>
00095 <span class="comment">// .width is used only to find a new scanline, and can be changed at will</span>
00096 <span class="comment">//        the width is given in pixels and it can be arbitrary (no alignement needed)</span>
00097 <span class="comment">// for normal drawing primitives, (0,0) is the word-aligned address pointed by .addr,</span>
00098 <span class="comment">// disregarding of the values in .x and .y</span>
00099 <span class="comment">// for bitblt operations, .x and .y give the origin (top-left corner) of the region to use</span>
00100 <span class="comment">// the surface is nibble-aligned, so a 1 pixel wide surface will contain 8</span>
00101 <span class="comment">// rows of pixels per word</span>
00102 
<a name="l00112"></a><a class="code" href="structgglsurface.html">00112</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00113"></a><a class="code" href="structgglsurface.html#o0">00113</a>         <span class="keywordtype">int</span> *addr;  
<a name="l00114"></a><a class="code" href="structgglsurface.html#o1">00114</a>         <span class="keywordtype">int</span> width;  
<a name="l00115"></a><a class="code" href="structgglsurface.html#o3">00115</a>         <span class="keywordtype">int</span> x,y;    
00116 } <a class="code" href="structgglsurface.html">gglsurface</a>;
00117 
<a name="l00138"></a><a class="code" href="ggl_8h.html#a7">00138</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> int (*<a class="code" href="ggl_8h.html#a7">gglfilter</a>)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pixels,<span class="keywordtype">int</span> param);
00139 
<a name="l00159"></a><a class="code" href="ggl_8h.html#a8">00159</a> <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> int (*<a class="code" href="ggl_8h.html#a8">ggloperator</a>)(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dest,<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> source,<span class="keywordtype">int</span> param);
00160 
00161 
00162 <span class="comment">// general routines</span>
00163 
00175 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a9">ggl_initscr</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf);      <span class="comment">// allocate screen buffer</span>
00176 
00188 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a10">ggl_gethpgscreen</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf);
00189 
<a name="l00205"></a><a class="code" href="ggl_8h.html#a4">00205</a> <span class="preprocessor">#define ggl_setmode(framebuf) sys_lcdsetmode(MODE_16GRAY,framebuf);</span>
00206 <span class="preprocessor"></span>
00207 
<a name="l00230"></a><a class="code" href="ggl_8h.html#a5">00230</a> <span class="preprocessor">#define ggl_save(buf) sys_lcdsave(buf)</span>
00231 <span class="preprocessor"></span>
00252 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a11">ggl_restore</a>(<span class="keywordtype">int</span> *buf);     <span class="comment">// restore saved LCD state</span>
00253 
00254 <span class="comment">/*</span>
00255 <span class="comment"> * \brief Causes a different GGL surface to be displayed.</span>
00256 <span class="comment"> *</span>
00257 <span class="comment"> * This function allows the use of several GGL surfaces as the main screen</span>
00258 <span class="comment"> * in an application. It causes the LCD controller to begin displaying a</span>
00259 <span class="comment"> * different screen.  No VSYNC is performed, so some tearing is possible </span>
00260 <span class="comment"> * unless external VSYNC is checked before calling this function.</span>
00261 <span class="comment"> *</span>
00262 <span class="comment"> * This function should be used by applications that use GGL exclusively.  If</span>
00263 <span class="comment"> * HPG is in use, the application should use hpg_flip to accomplish page</span>
00264 <span class="comment"> * flipping.</span>
00265 <span class="comment"> *</span>
00266 <span class="comment"> * \param framebuf A pointer to the new LCD screen's frame buffer.  This is</span>
00267 <span class="comment"> *                 generally found in the gglsurface::addr field of a</span>
00268 <span class="comment"> *                 ::gglsurface.</span>
00269 <span class="comment"> */</span>
00270 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a12">ggl_show</a>(<span class="keywordtype">int</span> *buffer);     <span class="comment">// display buffer, no vertical sync</span>
00271 
00272 <span class="comment">// drawing primitives</span>
00273 <span class="comment">// general pixel set/read routines</span>
00274 
00289 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a13">ggl_pltnib</a>(<span class="keywordtype">int</span> *buff,<span class="keywordtype">int</span> off,<span class="keywordtype">int</span> color);   <span class="comment">// poke a pixel (off in nibbles)</span>
00290 
00306 <span class="keywordtype">int</span>  <a class="code" href="ggl_8h.html#a14">ggl_getnib</a>(<span class="keywordtype">int</span> *buff,<span class="keywordtype">int</span> off);                             <span class="comment">// peek a pixel (off in nibbles)</span>
00307 
00308 <span class="comment">// general drawing primitives</span>
00309 
00310 <span class="comment">// note: the argument color is a 32-bit value containing a different</span>
00311 <span class="comment">//       color for each pixel. For solid colors, set color to contain the same value</span>
00312 <span class="comment">//       on every nibble (for color 8, color=0x88888888)</span>
00313 <span class="comment">//       or call ggl_mkcolor for that purpose</span>
00314 
00333 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a15">ggl_hline</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> y,<span class="keywordtype">int</span> xl,<span class="keywordtype">int</span> xr, <span class="keywordtype">int</span> color); <span class="comment">// fast low-level horizontal line</span>
00334 
00354 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a16">ggl_vline</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x,<span class="keywordtype">int</span> yt,<span class="keywordtype">int</span> yb, <span class="keywordtype">int</span> color); <span class="comment">// fast low-level vertical line</span>
00355 
00377 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a17">ggl_rect</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x1,<span class="keywordtype">int</span> y1,<span class="keywordtype">int</span> x2,<span class="keywordtype">int</span> y2,<span class="keywordtype">int</span> color); <span class="comment">// low-level rectangle</span>
00378 
00398 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a18">ggl_rectp</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x1,<span class="keywordtype">int</span> y1,<span class="keywordtype">int</span> x2,<span class="keywordtype">int</span> y2,<span class="keywordtype">int</span> *color); <span class="comment">// low-level rectangle with 8x8 pattern</span>
00399 
00400 <span class="comment">// rectangle blt</span>
00401 <span class="comment">// note: see gglsurface above for complete understanding of the behavior of these routines</span>
00402 <span class="comment">// ggl_bitblt loops from top to bottom</span>
00403 
00424 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a19">ggl_bitblt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height); <span class="comment">// copy a rectangular region</span>
00425 
00426 <span class="comment">// ggl_revblt loops from bottom to top, for overlapping zones</span>
00446 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a20">ggl_revblt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height); <span class="comment">// copy a rectangular region, reverse loop</span>
00447 <span class="comment">// ggl_ovlblt chooses to use normal/reverse loop based on the addresses</span>
00448 <span class="comment">// use it when the direcction of movement is unknown</span>
00468 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a21">ggl_ovlblt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height); <span class="comment">// copy overlapped regions</span>
00469 <span class="comment">// ggl_bitbltmask behaves exactly as ggl_bitblt but using tcol as a transparent color</span>
00470 
00471 
<a name="l00494"></a><a class="code" href="ggl_8h.html#a6">00494</a> <span class="preprocessor">#define ggl_bitbltmask(dest,src,width,height,tcol)  ggl_bitbltoper(dest,src,width,height,tcol,&amp;ggl_opmask)</span>
00495 <span class="preprocessor"></span>
00496 
00497 <span class="comment">// rectangle scrolling routines</span>
00498 <span class="comment">// dest contains the surface to scroll, and width and height define the rectangle</span>
00499 <span class="comment">// the area that needs to be redrawn after the scroll is not erased or modified by these routines </span>
00517 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a22">ggl_scrollup</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels up</span>
00536 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a23">ggl_scrolldn</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels dn</span>
00537 
00555 <span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a24">ggl_scrolllf</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels left</span>
00573 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a25">ggl_scrollrt</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> npixels); <span class="comment">// scroll npixels right</span>
00574 
00575 <span class="comment">// custom filters and operators</span>
00576 
00577 <span class="comment">// bitmap filtering routine</span>
00596 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a26">ggl_filter</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height, <span class="keywordtype">int</span> param, <a class="code" href="ggl_8h.html#a7">gglfilter</a> filterfunc);
00597 
00598 <span class="comment">// bitblt operator routine</span>
00620 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a27">ggl_bitbltoper</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *dest,<a class="code" href="structgglsurface.html">gglsurface</a> *src,<span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height,<span class="keywordtype">int</span> param,<a class="code" href="ggl_8h.html#a8">ggloperator</a> fop);
00621 
00622 <span class="comment">// predefined filters and operators</span>
00623 
00624 <span class="comment">// filters (unary operators)</span>
00625 <span class="comment">// ligthens an image by subtracting param from all pixels</span>
00626 
00639 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a28">ggl_fltlighten</a>(<span class="keywordtype">unsigned</span> word,<span class="keywordtype">int</span> param);
00640 <span class="comment">// darkens an image by adding param to all pixels</span>
00641 
00654 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a29">ggl_fltdarken</a>(<span class="keywordtype">unsigned</span> word,<span class="keywordtype">int</span> param);
00655 
00656 <span class="comment">// operators (between two surfaces)</span>
00657 <span class="comment">// standard mask, tcolor in src is considered transparent</span>
00658 
00659 
00674 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a30">ggl_opmask</a>(<span class="keywordtype">unsigned</span> dest,<span class="keywordtype">unsigned</span> src,<span class="keywordtype">int</span> tcolor);
00675 <span class="comment">// transparency blend, weight is 0 = src is opaque, 16 = src is fully transparent</span>
00676 
00692 <span class="keywordtype">unsigned</span> <a class="code" href="ggl_8h.html#a31">ggl_optransp</a>(<span class="keywordtype">unsigned</span> dest,<span class="keywordtype">unsigned</span> src,<span class="keywordtype">int</span> weight);
00693 
00694 
00695 
00696 
00697 <span class="comment">// miscellaneous</span>
00698 
00699 <span class="comment">// ggl_mkcolor repeats the same color on every nibble</span>
00700 <span class="comment">// ggl_mkcolor(2) will return 0x22222222</span>
00710 <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="ggl_8h.html#a32">ggl_mkcolor</a>(<span class="keywordtype">int</span> color); <span class="comment">// solid color generator</span>
00711 
00712 <span class="comment">// ggl_mkcolor32 creates virtual 32-colors by using 8x8 patterns</span>
00713 <span class="comment">// col32 is a value from 0 to 30, being 30=black, 0=white</span>
00714 <span class="comment">// note: the user is responsible to provide a valid int[8] buffer in the</span>
00715 <span class="comment">// pattern argument</span>
00729 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a33">ggl_mkcolor32</a>(<span class="keywordtype">int</span> col32, <span class="keywordtype">int</span> *pattern);    <span class="comment">// 50% dither pattern generator for 31 colors</span>
00730         
00731 <span class="comment">// ANTIALIAS INITIALIZATION</span>
00732 
00733 <span class="comment">// ggl_initaline initializes tables needed for antialiased lines</span>
00743 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a34">ggl_initaline</a>();
00744 
00745 <span class="comment">// for antialiased lines, call first ggl_initaline and call ggl_endaline for cleanup</span>
00746 <span class="comment">// notice that ggl_init/ggl_exit do NOT call ggl_initaline</span>
00747 <span class="comment">// anitaliased lines are always 3 pixels wide</span>
00763 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a35">ggl_aline</a>(<a class="code" href="structgglsurface.html">gglsurface</a> *srf,<span class="keywordtype">int</span> x1,<span class="keywordtype">int</span> y1,<span class="keywordtype">int</span> x2,<span class="keywordtype">int</span> y2);    <span class="comment">// ANTIALIASED LINES</span>
00764 
00765 <span class="comment">// ggl_endaline cleans up the memory allocated by ggl_initaline</span>
00775 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="ggl_8h.html#a36">ggl_endaline</a>();
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sun May 1 04:34:51 2005 for GGL by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
